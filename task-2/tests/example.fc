;; Each test function must specify method_id
;; Test functions method_id need to started from 0

;; Each test functions must to be in pairs
;; First funtion expect nothing in arguments
;; But need to return:
;;        function selector - which function to test, e.g. 0 for recv_internal, -1 recv_external, 85143 for seqno, and so on
;;        tuple - stack values needed to be passed to function in tuple
;;        c4 cell - start data of smart contract
;;        c7 tuple / null
;;        gas limit integer / null

[int, tuple, cell, tuple, int] test_example_data() method_id(0) {
    ;; TODO: CHANGE IT!

    ;; Funtion to run (recv_internal)
    int function_selector = 0;

    cell my_address = begin_cell()
                            .store_uint(1, 2) ;; 0x01 <- external
                            .store_uint(5, 9) ;; len = 5
                            .store_uint(7, 5) ;; let's say my address == "7"
                            .end_cell();

    cell their_address = begin_cell()
                        .store_uint(1, 2) ;; 0x01 <- external
                        .store_uint(5, 9) ;; len = 5
                        .store_uint(8, 5) ;; let's say my address == "8"
                        .end_cell();

    slice message_body = begin_cell().store_uint(12345, 32).end_cell().begin_parse();

    ;; Example contract message body
    cell message = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(their_address.begin_parse())
            .store_grams(100)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_slice(message_body)
            .end_cell();

    ;; int balance, int msg_value, cell in_msg_full, slice in_msg_body
    tuple stack = unsafe_tuple([12345, 100, message, message_body]);

    return [function_selector, stack, my_address, get_c7(), null()];
}


;; After test data function
;; We need to define test funtion
;; It will accept:
;;        exit code - exit code of runvm, here you can check errors / not
;;        c4 cell - data of smart contract after runvm invokes
;;        tuple - stack values of smart contract
;;        c5 cell - here you can check all outcoming messages
;;        gas - gas that was used
;; By default test is passed
;; You can use throw_if to fail test


forall X -> () dump (X x) impure asm "s0 DUMP DROP";

_ test_example(int exit_code, cell data, tuple stack, cell actions, int gas) method_id(1) {
     throw_if(100, exit_code != 0);

     slice actions = actions.begin_parse();

    ;; TODO: check actions...
     dump(actions);
}

