

{-

TASK 5 - SHARED WALLET.

The aim of two owner wallet is to create smart-contract which send messages then and only then both owners (represented by public keys) authorized it.

TL-B schema of external message body accepted by wallet is as follows:
```
request#_ valid_until:uint32 mode:uint8 msg_to_send:^Cell = Request;
mdg_body#_ public_key:uint256 signature:(512 * Bit) request:^Request = MsgBody;
```

Where `signature` signs `Request` cell with some private key and `public_key` is corresponding public key.

`msg_to_send` is fully formed message which is ready to be accepted by `send_raw_message()`.

Any errors related to the incorrect `msg_to_send` may be ignored (in other words if something goes wrong due to owner's malformed message, it is owner's problem).

When wallet receive request signed by one owner it should store it in storage.

When wallet receives the same request signed by another owner it should process request, that means send `msg_to_send` with `mode` in the same transaction it got second signature.

If request is signed not by owner, contains incorrect signature or current time is higher than `valid_until`, request should be ignored (message should not be accepted).

If the same request (regardless approved by one or both owners) is sent the second time it should be ignored.

It is acceptable to ignore requests which are valid for more than 1 minute as well as not accept more than 10 requests per minute.

Before running tests, storage for contract will be generated by `pack_data` with providing two public keys. Thus participants may intoduce their own storage layout.

-}


forall X -> () dump (X x) impure asm "s0 DUMP DROP";

;; testable
cell pack_data(int public_key1, int public_key2) method_id {
  return begin_cell().store_uint(public_key1, 256).store_uint(public_key2, 256).store_uint(0, 5 + 20).end_cell();
}

{-

First 3 requests are stored in-place, others are stored recursively in another node.

We have at most 3 tree cells:

[0 1 2 * ]
       |
       v
      [3 4 5 * ]
             |
             v
            [6 7  8 9]

Root cell also contains some additional information:
 - cnt requests (5 bit integer)
 - 10x (2 bits) - if request was approved by public_key1 & public_key2
 - cnt * (32 bits) - valid untils for stored requests
-}

(slice, int, int) load_data() inline {
  slice ds = get_data().begin_parse();
  int public_key1 = ds~load_uint(256);
  int public_key2 = ds~load_uint(256);
  return (ds, public_key1, public_key2);
}

;; Not used, faster version below
int find_request_old(slice s, int hash) inline {
  int pos = -1;
  int size = 0;
  int lvl = 1;

  while ((pos == -1) & (~ slice_refs_empty?(s))) {
    size += 1;
    cell ref = s~load_ref();
    if ((size == 4) | (size == 8)) {
      lvl += 1;
      s = ref.begin_parse();
    } else {
      if (cell_hash(ref) == hash) {
        pos = size - lvl;
      }
    }
  }
  return pos;
}

int find_request_inline(slice s, int hash) inline_ref {
  if (s.slice_refs() == 4) {
    if (cell_hash(s~load_ref()) == hash) {
      return 0;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 1;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 2;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 3;
    }
    return -100;
  }

  if (s.slice_refs() == 3) {
    if (cell_hash(s~load_ref()) == hash) {
      return 0;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 1;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 2;
    }
    return -100;
  }

  if (s.slice_refs() == 2) {
    if (cell_hash(s~load_ref()) == hash) {
      return 0;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 1;
    }
   return -100;
  }

  if (s.slice_refs() == 1) {
    if (cell_hash(s~load_ref()) == hash) {
      return 0;
    }
     return -100;
  }

  return -100;
}

int find_request(slice s, int hash) inline_ref {
  if (s.slice_refs() == 4) {
    if (cell_hash(s~load_ref()) == hash) {
      return 0;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 1;
    }
    if (cell_hash(s~load_ref()) == hash) {
      return 2;
    }
    s = s~load_ref().begin_parse();

    ;; start second lvl
    if (s.slice_refs() == 4) {
      if (cell_hash(s~load_ref()) == hash) {
        return 3;
      }
      if (cell_hash(s~load_ref()) == hash) {
        return 4;
      }
      if (cell_hash(s~load_ref()) == hash) {
        return 5;
      }
      s = s~load_ref().begin_parse();

      ;; start third lvl
      return 6 + find_request_inline(s, hash);
    }

    return 3 + find_request_inline(s, hash);
  }
  return find_request_inline(s, hash);
}

;; not used, faster version below
cell replace_request_old(builder b, slice old_slice, int pos, int lvl, cell request) {
  int cnt_inplace = 3;
  if (lvl == 2) {
    cnt_inplace += 1;
  }
  if (pos < cnt_inplace) {
    repeat(pos) {
      b = b.store_ref(old_slice~load_ref());
    }
    b = b.store_ref(request);
    if (~ old_slice.null?()) {
      if (~ old_slice.slice_refs_empty?()) {
        old_slice~load_ref();
      }
      repeat(old_slice.slice_refs()) {
        b = b.store_ref(old_slice~load_ref());
      }
    }
  } else {
    repeat(3) {
      b = b.store_ref(old_slice~load_ref());
    }
    slice children_old_slice = null();
    if (~ old_slice.slice_refs_empty?()) {
      children_old_slice = old_slice~load_ref().begin_parse();
    }
    cell children = replace_request_old(begin_cell(), children_old_slice, pos - 3, lvl + 1, request);
    b = b.store_ref(children);
  }
  return b.end_cell();
}

cell replace_request_2(builder b, slice old_slice, int pos, cell request) inline {
  repeat(pos) {
    b = b.store_ref(old_slice~load_ref());
  }
  b = b.store_ref(request);
  if (~ old_slice.null?()) {
    if (~ old_slice.slice_refs_empty?()) {
      old_slice~load_ref();
    }
    repeat(old_slice.slice_refs()) {
      b = b.store_ref(old_slice~load_ref());
    }
  }
  return b.end_cell();
}

cell replace_request_1(builder b, slice old_slice, int pos, cell request) inline {
  if (pos < 3) {
    repeat(pos) {
      b = b.store_ref(old_slice~load_ref());
    }
    b = b.store_ref(request);
    if (~ old_slice.null?()) {
      if (~ old_slice.slice_refs_empty?()) {
        old_slice~load_ref();
      }
      repeat(old_slice.slice_refs()) {
        b = b.store_ref(old_slice~load_ref());
      }
    }
  } else {
    repeat(3) {
      b = b.store_ref(old_slice~load_ref());
    }
    slice children_old_slice = null();
    if (~ old_slice.slice_refs_empty?()) {
      children_old_slice = old_slice~load_ref().begin_parse();
    }
    cell children = replace_request_2(begin_cell(), children_old_slice, pos - 3, request);
    b = b.store_ref(children);
  }
  return b.end_cell();
}

cell replace_request(builder b, slice old_slice, int pos, cell request) inline {
  if (pos < 3) {
    repeat(pos) {
      b = b.store_ref(old_slice~load_ref());
    }
    b = b.store_ref(request);
    if (~ old_slice.null?()) {
      if (~ old_slice.slice_refs_empty?()) {
        old_slice~load_ref();
      }
      repeat(old_slice.slice_refs()) {
        b = b.store_ref(old_slice~load_ref());
      }
    }
  } else {
    repeat(3) {
      b = b.store_ref(old_slice~load_ref());
    }
    slice children_old_slice = null();
    if (~ old_slice.slice_refs_empty?()) {
      children_old_slice = old_slice~load_ref().begin_parse();
    }
    cell children = replace_request_1(begin_cell(), children_old_slice, pos - 3, request);
    b = b.store_ref(children);
  }
  return b.end_cell();
}


builder store_builder(builder to, builder what) asm(what to) "STB";


;; testable
() recv_external (slice in_msg_body) {
  int public_key = in_msg_body~load_uint(256);
  slice signature = in_msg_body~load_bits(512);
  cell request_cell = in_msg_body~load_ref();
  in_msg_body.end_parse();

  slice request = request_cell.begin_parse();

  ;; TODO: uncomment it
  throw_if(100, ~ check_data_signature(request, signature, public_key));
  int valid_until = request~load_uint(32);
  throw_if(101, valid_until < now());
  throw_if(102, valid_until > now() + 60);

  accept_message();

  ;; TODO: validation
  (slice tree, int public_key1, int public_key2) = load_data();

  int key_mask = 0;
  if (public_key == public_key1) {
    key_mask = 1;
  } else {
    if (public_key == public_key2) {
      key_mask = 2;
    } else {
      throw(103);
    }
  }

  int cnt = tree~load_uint(5);
  int full_mask = tree~load_uint(20);
  slice valid_untils = tree~load_bits(32 * cnt);

  int pos = find_request(tree, cell_hash(request_cell));
  builder new_tree = begin_cell().store_uint(public_key1, 256).store_uint(public_key2, 256);

  if (pos < 0) {
    builder new_valid_untils = begin_cell();
    slice valid_untils_copy = valid_untils;
    int npos = 0;
    while (npos < cnt) {
      if (valid_untils_copy~load_uint(32) < now()) {
        npos += cnt;
      }
      npos += 1;
    }
    if (npos > cnt) {
      npos -= cnt + 1;
    }
    throw_if(104, npos == 10); ;; too many entries already
    new_valid_untils = new_valid_untils.store_slice(valid_untils~load_bits(npos * 32));
    new_valid_untils~store_uint(valid_until, 32);
    if (npos + 1 < cnt) {
      valid_untils~load_uint(32);
      new_valid_untils = new_valid_untils.store_slice(valid_untils);
    }

    int ncnt = max(cnt, npos + 1);
    new_tree~store_uint(ncnt, 5);
    int next_full_mask = full_mask & (~ (3 << (npos * 2)));
    next_full_mask |= (key_mask << (npos * 2));
    new_tree~store_uint(next_full_mask, 20);
    new_tree = new_tree.store_builder(new_valid_untils);
    cell root = replace_request(new_tree, tree, npos, request_cell);
    set_data(root);
  } else {
    int cur_mask = (full_mask >> (pos * 2)) & 3;
    int next_mask = cur_mask | key_mask;
    throw_if(105, cur_mask == next_mask);
    if (next_mask == 3) {
      int mode = request~load_uint(8);
      cell msg_to_send = request~load_ref();
      send_raw_message(msg_to_send, mode);
    }
    int next_full_mask = full_mask | ((next_mask << (pos * 2)));
    new_tree~store_uint(cnt, 5);
    new_tree~store_uint(next_full_mask, 20);
    new_tree = new_tree.store_slice(valid_untils);
    repeat(tree.slice_refs()) {
      new_tree = new_tree.store_ref(tree~load_ref());
    }
    set_data(new_tree.end_cell());
  }

}

;; just to make toncli tests work
() recv_internal () {

}